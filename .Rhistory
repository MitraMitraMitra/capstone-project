#par(mfrow=c(2,2))
#dev.new()
#options(device = "windows")
#x <- list()
#myplots <- vector('list', ncol(data1))
#typeof(myplots)
myplots <- list()
myplots[[1]] <- ggplot(data1,aes(x=Timestamp,y=Value))+
geom_point()
myplots[[2]] <- ggplot(data1,aes(x=Timestamp,y=Timestamp))+
geom_point()
#myplots <- list(x,y)
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 2, nrow = 2)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
data1 = fread(PATH)
data1
PATH[30]
PATH[2:5]
PATH(2)
substr(PATH,34)
substr(PATH,34,35)
substr(PATH,34,38)\
substr(PATH,34,38)
substr(PATH,56,57)
substr(PATH,50,51)
substr(PATH,53,58)
substr(PATH,53,61)
substr(PATH,53,64)
substr(PATH,64,65)
substr(PATH,65,65)
substr(PATH,-5,-2)
substr(PATH,length(PATH)-5,2)
substr(PATH,length(PATH)-20,length(PATH)-10)
substr(PATH,length(PATH)-20,10)
substr(PATH,length(PATH)-30,10)
length(PATH)
substr(PATH,str_length(PATH)-30,10)
substr(PATH,nchar(PATH)-30,10)
nchar(PATH)
substr(PATH,nchar(PATH)-40,70)
substr(PATH,nchar(PATH)-20,78)
substr(PATH,nchar(PATH)-25,78)
substr(PATH,nchar(PATH)-15,78)
substr(PATH,nchar(PATH)-14,78)
substr(PATH,nchar(PATH)-14,nchar(PATH)-15)
substr(PATH,nchar(PATH)-14,nchar(PATH)-14)
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
PATH
PATH
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
data1 = fread(PATH)
}
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
}
#par(mfrow=c(2,2))
#dev.new()
#options(device = "windows")
#x <- list()
#myplots <- vector('list', ncol(data1))
#typeof(myplots)
myplots <- list()
myplots[[1]] <- ggplot(data1,aes(x=Timestamp,y=Value))+
geom_point()
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-i
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- char(i)
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- string(i)
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
}
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
#myplots <- list(x,y)
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
#myplots[[2]] <- ggplot(data1,aes(x=Timestamp,y=Timestamp))+
#  geom_point()
#myplots <- list(x,y)
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
#substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
#PATH
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
#myplots[[2]] <- ggplot(data1,aes(x=Timestamp,y=Timestamp))+
#  geom_point()
#myplots <- list(x,y)
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
library(data.table)
library(data.table)
library(ggplot2)
library(plotly)
library(seewave)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
#substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
#PATH
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
#data <- transform(data, DisplayValue = as.numeric(DisplayValue))
#dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
#1099511627776
#rm(data)
#object.size(data)
#time <- data$Timestamp
#value <- data$Value
#length(value)
#length(time)
#View(data)
#str(data)
library(data.table)
library(ggplot2)
library(plotly)
library(seewave)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
#substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <-'2'
#PATH
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
#data <- transform(data, DisplayValue = as.numeric(DisplayValue))
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
#1099511627776
#rm(data)
#object.size(data)
#time <- data$Timestamp
#value <- data$Value
#length(value)
#length(time)
#View(data)
#str(data)
data$Quality
#rm(data)
object.size(myplots)
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
dev.new()
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
dev.new()
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
library(data.table)
library(ggplot2)
#install.packages('bit64')
#install.packages("ggpubr")
library(bit64)
library(ggpubr)
PATH = 'C:/Users/jeanm/Documents/GitHub/data/sound_analysis/intensity/L01_intensity.csv'
# This FOR loop is used to read the data
# from all .csv files in the INTENSITY folder,
# generate time vs. value plots and append them
# to the MYPLOTS list
x <- c(1,2,3,4,5,6,9)
myplots <- list()
for (i in x) {
substr(PATH,nchar(PATH)-14,nchar(PATH)-14) <- as.character(i)
data = fread(PATH)
data <- data[QualityGood == TRUE]
myplots[[i]] <- local({
i <- i
p <- ggplot(data,aes(x=Timestamp,y=Value))+
geom_point()
})
}
# This command is used to create a new window;
# the plots will be displayed there.
dev.new()
ggarrange(plotlist = myplots,
labels = c("A", "B"),
ncol = 3, nrow = 3)
# The DisplayValue column of the .csv files
# in the INTENSITY folder is of type CHAR,
# even though it stores numbers.
# So, if you ever want to work with that,
# make sure to run this command first:
# data <- transform(data, DisplayValue = as.numeric(DisplayValue))
# FUN FACT:
# The vast majority of rows in the 'L01_intensity.csv' file
# have the Quality parameter equal to 0, but some of them
# are equal to 1099511627776, which happens to be equal to
# the number of bytes in a terabyte, as a binary number.
# To check the data, I recommend these commands:
#summary(data)
#View(data)
#str(data)
# Since we are working with more data than usual,
# you may want to clear the variables every now and then.
# You can just give this function
# whatever you want R to forget:
#rm(data)
# This command is useful to check the size of something:
#object.size(myplots)
